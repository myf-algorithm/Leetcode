| 排序方法 | 时间复杂度（平均） | 时间复杂度（最坏）| 时间复杂度（最好）| 空间复杂度 | 稳定性 |
| ----- | ---- | ---- | ---- | ---- | ---- | 
| 插入排序| O(n^2)| O(n^2) | O(n) | O(1) | 稳定 | 
| 希尔排序| O(n^1.3)| O(n^2) | O(n) | O(1) | 不稳定 | 
| 选择排序| O(n^2)| O(n^2) | O(n^2) | O(1) | 不稳定 | 
| 堆排序| O(nlogn)| O(nlogn) | O(nlogn) | O(1) | 不稳定 | 
| 冒泡排序| O(n^2)| O(n^2) | O(n) | O(1) | 稳定 | 
| 快速排序| O(nlogn)| O(n^2) | O(nlogn) | O(nlogn) | 不稳定 | 
| 归并排序| O(nlogn)| O(nlogn) | O(nlogn) | O(n) | 稳定 | 
| | | | | | | 
| 计数排序| O(n+maxV-minV)| O(n+maxV-minV) | O(n+maxV-minV) | O(maxV-minV) | 稳定 | 
| 桶排序| O(n+k)| O(n^2) | O(n) | O(n+k) | 稳定 | 
| 基数排序| O(nd)| O(nd) | O(nd) | O(n+k) | 稳定 | 

- 冒泡排序：

  ```
  1：比较相邻的元素，如果第一个比第二个大（升序），就交换他们两个
  2：对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对
  3：针对所有的元素重复以上的步骤，除了最后一个
  4：持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较
  ```

- 选择排序：

  ```
  1：在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
  2：再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾
  3：直到所有元素均排序完毕
  ```

- 插入排序：

  ```
  1：构建有序序列
  2：对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入
  3：在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间
  ```

- 希尔排序：

  ```
  1：是插入排序的一种，也叫缩小增量排序
  2：时间复杂度会比O(n^2)好一点，空间复杂度为O(1)
  3：相同的元素在各自的组内进行插入排序
  ```

- 归并排序：

  ```
  1：归并排序的思想就是先递归分解数组，再合并数组
  2：将数组分解最小之后，然后合并两个有序数组
  3：基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位
  4：然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可
  ```

- 快速排序：

  ```
  快速排序是对冒泡排序的改良，又称划分交换排序（partition-exchange sort）
  通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小
  然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列
  1：从数列中挑出一个元素，称为"基准"（pivot）
  2：重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作
  3：递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序
  
  递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了，虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。
  ```

